#ifndef GAUSSJORDAN_H_
#define GAUSSJORDAN_H_

#include <vector>
#include <list>
#include <math.h>

/*
 * Find x in Ax=y, where A is an M*N matrix and x and y
 * are vectors of length N.  
 * 
 */
template<int M, int N>
int gaussjordanplus(double A[M][N], double y[N], std::vector<double> &x)
{
	std::vector<double*> _A(M);
	for(int i=0; i<M; ++i)
		_A[i]=A[i];
	
	
	bool linear_independent_lines=true;
	bool matrix_is_zero=true;
	for(int i=0; i<std::min(M, N); ++i)
	{
		bool non_zero_line=false;
		for(int j=i; j<M; ++j)
		{
			if(_A[j][i]!=0)
			{
				matrix_is_zero=false;
				non_zero_line=true;
				std::swap(y[i], y[j]);
				std::swap(_A[i], _A[j]);
				break;
			}
		}
		if(!non_zero_line)
		{
			linear_independent_lines=false;
			continue;
		}
		
		double A_i_i=_A[i][i];
		for(int j=i+1; j<M; ++j)
		{
			double factor=_A[j][i]/A_i_i;
			double line_sum=0;
			y[j] -= y[i]*factor; 
			for(int z=i; z<N; ++z)
			{
				_A[j][z] -= _A[i][z]*factor;
				line_sum += _A[j][z]; 
			}
			if(line_sum==0)
			{
				linear_independent_lines=false;
				if(y[j]!=0)
				{
					return 0;
				}
				
			}
		}
	}
	x.clear();
	x.reserve(N);
	if(matrix_is_zero)
	{
		//The matrix is all zeros, if y isn't the zero vector
		//then the equation is inconsistent.
		for(int i=0; i<N; ++i)
		{
			if(y[i]!=0)
				return 0;
		}
		for(int i=0; i<N; ++i)
			x[i]=-666;
		return 2;
	}
	for(int i=0; i<N; ++i)
	{
		x[i]=y[i];
	}
	for(int i=std::min(M, N)-1; i>=0; --i)
	{
		double A_i_i=_A[i][i];
		if(sqrt(A_i_i*A_i_i)<0.0001)
			continue;
		std::list<int> non_zero_positions;
		for(int j=0; j<N; ++j)
		{
			if(A[i][j]!=0)
				non_zero_positions.push_back(j);
		}
		if(non_zero_positions.size()>1)
		{
			for(std::list<int>::iterator it=non_zero_positions.begin(); it!=non_zero_positions.end(); ++it)
			{
				x[*it]=-666;
			}
			continue;
		}
		for(int j=i-1; j>=0; --j)
		{
			x[j] -= x[i]*A[j][i]/A_i_i; 
			A[j][i]=0;
		}
	}
	for(int i=0; i<M; ++i)
	{
		for(int j=0; j<N; ++j)
		{
			printf("%lf ", A[i][j]);
		}
		printf("\n");
	}
	for(int i=0; i<N; ++i)
	{
		if(x[i]!=-666 || sqrt(_A[i][i]*_A[i][i])>0.0001)
			x[i] /= _A[i][i];
	}
	return 1;
}

template<int M, int N>
int gaussjordan(double A[M][N], double y[N], std::vector<double> &x)
{
	std::vector<double*> _A(M);
	for(int i=0; i<M; ++i)
		_A[i]=A[i];
	
	
	bool linear_independent_lines=true;
	bool matrix_is_zero=true;
	for(int i=0; i<std::min(M, N); ++i)
	{
		bool non_zero_line=false;
		for(int j=i; j<M; ++j)
		{
			if(_A[j][i]!=0)
			{
				matrix_is_zero=false;
				non_zero_line=true;
				std::swap(y[i], y[j]);
				std::swap(_A[i], _A[j]);
				break;
			}
		}
		if(!non_zero_line)
		{
			linear_independent_lines=false;
			continue;
		}
		
		double A_i_i=_A[i][i];
		for(int j=i+1; j<M; ++j)
		{
			double factor=_A[j][i]/A_i_i;
			double line_sum=0;
			y[j] -= y[i]*factor; 
			for(int z=i; z<N; ++z)
			{
				_A[j][z] -= _A[i][z]*factor;
				line_sum += _A[j][z]; 
			}
			if(line_sum==0)
			{
				linear_independent_lines=false;
				if(y[j]!=0)
				{
					return 0;
				}
				
			}
		}
	}
	if(matrix_is_zero)
	{
		//The matrix is all zeros, if we can find an y_i!=0 then
		//the equation is inconsistent.
		for(int i=0; i<N; ++i)
		{
			if(y[i]!=0)
				return 0;
		}
		return 2;
	}
	if(!linear_independent_lines)
	{
		return 2;
	}
	x.clear();
	x.reserve(N);
	for(int i=0; i<N; ++i)
	{
		x[i]=y[i];
	}
	for(int i=std::min(M, N)-1; i>=0; --i)
	{
		double A_i_i=_A[i][i];
		for(int j=i-1; j>=0; --j)
		{
			x[j] -= x[i]*A[j][i]/A_i_i; 
		}
	}
	for(int i=0; i<N; ++i)
	{
		x[i] /= _A[i][i];
	}
	return 1;
}
#endif /*GAUSSJORDAN_H_*/
